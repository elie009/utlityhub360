using Microsoft.EntityFrameworkCore;
using UtilityHub360.Data;
using UtilityHub360.DTOs;
using UtilityHub360.Entities;
using UtilityHub360.Models;

namespace UtilityHub360.Services
{
    public class BillService : IBillService
    {
        private readonly ApplicationDbContext _context;
        private readonly AccountingService _accountingService;

        public BillService(ApplicationDbContext context, AccountingService accountingService)
        {
            _context = context;
            _accountingService = accountingService;
        }

        public async Task<ApiResponse<BillDto>> CreateBillAsync(CreateBillDto createBillDto, string userId)
        {
            try
            {
                // ============================================
                // VALIDATION: Only allow bills for current year
                // ============================================
                var currentYear = DateTime.UtcNow.Year;
                var billYear = createBillDto.DueDate.Year;

                if (billYear != currentYear)
                {
                    return ApiResponse<BillDto>.ErrorResult(
                        $"Bills can only be created for the current year ({currentYear}). " +
                        $"You tried to create a bill for {createBillDto.DueDate:MMMM yyyy}. " +
                        $"Please select a date within {currentYear}.");
                }

                Console.WriteLine($"DEBUG CREATE BILL: Validation passed - Bill year {billYear} matches current year {currentYear}");

                var billId = Guid.NewGuid().ToString();
                
                var bill = new Bill
                {
                    Id = billId,
                    UserId = userId,
                    BillName = createBillDto.BillName,
                    BillType = createBillDto.BillType.ToLower(),
                    Amount = createBillDto.Amount,
                    DueDate = createBillDto.DueDate,
                    Frequency = createBillDto.Frequency.ToLower(),
                    Status = "PENDING",
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow,
                    Notes = createBillDto.Notes,
                    Provider = createBillDto.Provider,
                    ReferenceNumber = createBillDto.ReferenceNumber,
                    AutoGenerateNext = createBillDto.AutoGenerateNext,
                    IsAutoGenerated = false,
                    ParentBillId = null, // Parent bill has no parent
                    IsScheduledPayment = createBillDto.IsScheduledPayment,
                    ScheduledPaymentBankAccountId = createBillDto.ScheduledPaymentBankAccountId,
                    ScheduledPaymentDaysBeforeDue = createBillDto.ScheduledPaymentDaysBeforeDue,
                    ApprovalStatus = "APPROVED" // Default to approved
                };

                _context.Bills.Add(bill);

                // Create accrual accounting entry when bill is received/created
                // Accrual Basis: Debit Expense, Credit Accounts Payable
                await _accountingService.CreateBillAccrualEntryAsync(
                    billId,
                    userId,
                    createBillDto.Amount,
                    createBillDto.BillName,
                    createBillDto.BillType,
                    createBillDto.ReferenceNumber,
                    $"Bill received: {createBillDto.BillName}",
                    DateTime.UtcNow
                );

                // If AutoGenerateNext is enabled, create bills ONLY for remaining months of current year
                if (createBillDto.AutoGenerateNext && createBillDto.Frequency.ToLower() == "monthly")
                {
                    var now = DateTime.UtcNow;
                    // Use the currentYear variable already declared above
                    var baseDueDay = createBillDto.DueDate.Day;
                    var billDueDate = createBillDto.DueDate.Date;
                    var billMonth = billDueDate.Month;

                    Console.WriteLine($"DEBUG AUTO-GEN: Starting auto-generation. Current year: {currentYear}, Bill month: {billMonth}");

                    int generatedCount = 0;
                    int skippedCount = 0;
                    
                    // Only generate bills for remaining months of the current year
                    for (int month = billMonth + 1; month <= 12; month++)
                    {
                        // Calculate due date for this month, handling months with fewer days
                        var daysInMonth = DateTime.DaysInMonth(currentYear, month);
                        var dueDay = Math.Min(baseDueDay, daysInMonth);
                        var monthlyDueDate = new DateTime(currentYear, month, dueDay);

                        // Skip if this date has already passed and is more than 30 days old
                        if (monthlyDueDate < now.Date.AddDays(-30))
                        {
                            skippedCount++;
                            Console.WriteLine($"DEBUG AUTO-GEN: Skipping {monthlyDueDate:yyyy-MM-dd} - too far in the past");
                            continue;
                        }

                        var monthlyBill = new Bill
                        {
                            Id = Guid.NewGuid().ToString(),
                            UserId = userId,
                            BillName = createBillDto.BillName,
                            BillType = createBillDto.BillType.ToLower(),
                            Amount = createBillDto.Amount, // Same amount for all months initially
                            DueDate = monthlyDueDate,
                            Frequency = "monthly",
                            Status = "PENDING",
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow,
                            Notes = $"Auto-generated for {monthlyDueDate:MMMM yyyy}",
                            Provider = createBillDto.Provider,
                            ReferenceNumber = createBillDto.ReferenceNumber,
                            AutoGenerateNext = true,
                            IsAutoGenerated = true,
                            ParentBillId = billId // Link to parent bill
                        };

                        _context.Bills.Add(monthlyBill);
                        
                        // Create accrual accounting entry for auto-generated bill
                        await _accountingService.CreateBillAccrualEntryAsync(
                            monthlyBill.Id,
                            userId,
                            createBillDto.Amount,
                            monthlyBill.BillName,
                            monthlyBill.BillType,
                            monthlyBill.ReferenceNumber,
                            $"Auto-generated bill for {monthlyDueDate:MMMM yyyy}",
                            DateTime.UtcNow
                        );
                        
                        generatedCount++;
                        Console.WriteLine($"DEBUG AUTO-GEN: Generated bill for {monthlyDueDate:yyyy-MM-dd}");
                    }
                    
                    Console.WriteLine($"DEBUG AUTO-GEN: Auto-generation complete. Generated: {generatedCount}, Skipped: {skippedCount} bills");
                }

                await _context.SaveChangesAsync();

                var billDto = MapToBillDto(bill);
                var message = createBillDto.AutoGenerateNext && createBillDto.Frequency.ToLower() == "monthly" 
                    ? $"Bill created successfully with auto-generation for remaining months of {DateTime.UtcNow.Year}" 
                    : "Bill created successfully";
                
                return ApiResponse<BillDto>.SuccessResult(billDto, message);
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to create bill: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillDto>> GetBillAsync(string billId, string userId)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                var billDto = MapToBillDto(bill);
                return ApiResponse<BillDto>.SuccessResult(billDto);
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to get bill: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillDto>> UpdateBillAsync(string billId, UpdateBillDto updateBillDto, string userId)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                // Update fields if provided
                if (!string.IsNullOrEmpty(updateBillDto.BillName))
                    bill.BillName = updateBillDto.BillName;

                if (!string.IsNullOrEmpty(updateBillDto.BillType))
                    bill.BillType = updateBillDto.BillType.ToLower();

                if (updateBillDto.Amount.HasValue)
                    bill.Amount = updateBillDto.Amount.Value;

                if (updateBillDto.DueDate.HasValue)
                {
                    // ============================================
                    // VALIDATION: Only allow due dates for current year
                    // ============================================
                    var currentYear = DateTime.UtcNow.Year;
                    var newDueDateYear = updateBillDto.DueDate.Value.Year;

                    if (newDueDateYear != currentYear)
                    {
                        return ApiResponse<BillDto>.ErrorResult(
                            $"Bill due dates can only be set for the current year ({currentYear}). " +
                            $"You tried to set a due date for {updateBillDto.DueDate.Value:MMMM yyyy}. " +
                            $"Please select a date within {currentYear}.");
                    }

                    bill.DueDate = updateBillDto.DueDate.Value;
                }

                if (!string.IsNullOrEmpty(updateBillDto.Frequency))
                    bill.Frequency = updateBillDto.Frequency.ToLower();

                if (!string.IsNullOrEmpty(updateBillDto.Status))
                    bill.Status = updateBillDto.Status.ToUpper();

                if (updateBillDto.Notes != null)
                    bill.Notes = updateBillDto.Notes;

                if (updateBillDto.Provider != null)
                    bill.Provider = updateBillDto.Provider;

                if (updateBillDto.ReferenceNumber != null)
                    bill.ReferenceNumber = updateBillDto.ReferenceNumber;

                if (updateBillDto.AutoGenerateNext.HasValue)
                    bill.AutoGenerateNext = updateBillDto.AutoGenerateNext.Value;

                bill.UpdatedAt = DateTime.UtcNow;

                await _context.SaveChangesAsync();

                var billDto = MapToBillDto(bill);
                return ApiResponse<BillDto>.SuccessResult(billDto, "Bill updated successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to update bill: {ex.Message}");
            }
        }

        public async Task<ApiResponse<bool>> DeleteBillAsync(string billId, string userId)
        {
            try
            {
                Console.WriteLine($"DEBUG DELETE: Starting delete for BillId: {billId}, UserId: {userId}");

                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    Console.WriteLine($"DEBUG DELETE: Bill not found for BillId: {billId}, UserId: {userId}");
                    return ApiResponse<bool>.ErrorResult("Bill not found");
                }

                Console.WriteLine($"DEBUG DELETE: Bill found - Name: {bill.BillName}, Amount: {bill.Amount}, ParentBillId: {bill.ParentBillId}");

                // Find all related bills using ParentBillId
                // If this bill is a parent (ParentBillId is null), find all children
                // If this bill is a child (ParentBillId is set), find the parent and all siblings
                var parentId = bill.ParentBillId ?? bill.Id;
                
                var relatedBills = await _context.Bills
                    .Where(b => b.UserId == userId &&
                               (b.Id == parentId || b.ParentBillId == parentId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG DELETE: Found {relatedBills.Count} related bills to delete (ParentId: {parentId})");

                // Get all bill IDs to delete
                var billIdsToDelete = relatedBills.Select(b => b.Id).ToList();

                // Delete all related payments for ALL bills
                var relatedPayments = await _context.Payments
                    .Where(p => billIdsToDelete.Contains(p.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG DELETE: Found {relatedPayments.Count} related payments across all bills");

                if (relatedPayments.Any())
                {
                    // For each payment, if it's a bank transaction, we need to handle it properly
                    foreach (var payment in relatedPayments)
                    {
                        Console.WriteLine($"DEBUG DELETE: Processing payment {payment.Id}, IsBankTransaction: {payment.IsBankTransaction}");
                        
                        // If it's a bank transaction, reverse the balance and delete BankTransaction record
                        if (payment.IsBankTransaction && payment.BankAccountId != null)
                        {
                            var bankAccount = await _context.BankAccounts
                                .FirstOrDefaultAsync(ba => ba.Id == payment.BankAccountId);

                            if (bankAccount != null)
                            {
                                Console.WriteLine($"DEBUG DELETE: Reversing bank balance: {bankAccount.CurrentBalance} + {payment.Amount}");
                                // Reverse the transaction (add back the amount since it was a debit)
                                bankAccount.CurrentBalance += payment.Amount;
                                bankAccount.UpdatedAt = DateTime.UtcNow;
                            }

                            // Delete the corresponding BankTransaction record
                            var bankTransaction = await _context.BankTransactions
                                .FirstOrDefaultAsync(bt => bt.ReferenceNumber == payment.Reference);

                            if (bankTransaction != null)
                            {
                                Console.WriteLine($"DEBUG DELETE: Removing BankTransaction {bankTransaction.Id}");
                                _context.BankTransactions.Remove(bankTransaction);
                            }
                        }
                    }

                    Console.WriteLine($"DEBUG DELETE: Removing {relatedPayments.Count} payments");
                    _context.Payments.RemoveRange(relatedPayments);
                }

                // Delete any related bill alerts for ALL bills
                var relatedAlerts = await _context.BillAlerts
                    .Where(a => billIdsToDelete.Contains(a.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG DELETE: Found {relatedAlerts.Count} related alerts across all bills");

                if (relatedAlerts.Any())
                {
                    _context.BillAlerts.RemoveRange(relatedAlerts);
                }

                // Now delete all related bills
                Console.WriteLine($"DEBUG DELETE: Removing {relatedBills.Count} bills from Bills table");
                Console.WriteLine($"DEBUG DELETE: Bill IDs to delete: {string.Join(", ", billIdsToDelete)}");
                
                _context.Bills.RemoveRange(relatedBills);
                
                Console.WriteLine($"DEBUG DELETE: Calling SaveChangesAsync...");
                var changeCount = await _context.SaveChangesAsync();
                Console.WriteLine($"DEBUG DELETE: SaveChanges completed. Changes saved: {changeCount}");

                // Verify deletion from database
                var stillExists = await _context.Bills
                    .Where(b => billIdsToDelete.Contains(b.Id))
                    .CountAsync();
                
                Console.WriteLine($"DEBUG DELETE: Verification - Bills still in database: {stillExists}");

                if (stillExists > 0)
                {
                    Console.WriteLine($"DEBUG DELETE WARNING: {stillExists} bills still exist in database after delete!");
                    return ApiResponse<bool>.ErrorResult($"Delete partially failed - {stillExists} bills still remain in database");
                }

                var successMessage = relatedBills.Count > 1 
                    ? $"Successfully deleted {relatedBills.Count} bills (including all auto-generated months) and all related records from database" 
                    : "Bill and all related records deleted successfully from database";
                
                return ApiResponse<bool>.SuccessResult(true, successMessage);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG DELETE ERROR: {ex.Message}");
                Console.WriteLine($"DEBUG DELETE ERROR STACK: {ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"DEBUG DELETE INNER ERROR: {ex.InnerException.Message}");
                }
                return ApiResponse<bool>.ErrorResult($"Failed to delete bill: {ex.Message}");
            }
        }

        public async Task<ApiResponse<PaginatedResponse<BillDto>>> GetUserBillsAsync(string userId, string? status, string? billType, int page, int limit)
        {
            try
            {
                // Validate and limit the maximum page size to prevent performance issues
                const int maxLimit = 1000;
                if (limit > maxLimit)
                {
                    limit = maxLimit;
                }

                if (page < 1)
                {
                    page = 1;
                }

                var query = _context.Bills.Where(b => b.UserId == userId);

                if (!string.IsNullOrEmpty(status))
                {
                    query = query.Where(b => b.Status == status.ToUpper());
                }

                if (!string.IsNullOrEmpty(billType))
                {
                    query = query.Where(b => b.BillType == billType.ToLower());
                }

                var totalCount = await query.CountAsync();
                
                // Calculate skip value safely
                var skip = (page - 1) * limit;
                if (skip < 0)
                {
                    skip = 0;
                }

                var bills = await query
                    .OrderByDescending(b => b.CreatedAt)
                    .Skip(skip)
                    .Take(limit)
                    .ToListAsync();

                var billDtos = bills.Select(MapToBillDto).ToList();

                var paginatedResponse = new PaginatedResponse<BillDto>
                {
                    Data = billDtos,
                    Page = page,
                    Limit = limit,
                    TotalCount = totalCount
                };

                return ApiResponse<PaginatedResponse<BillDto>>.SuccessResult(paginatedResponse);
            }
            catch (Exception ex)
            {
                // Log the full exception for debugging
                System.Diagnostics.Debug.WriteLine($"GetUserBillsAsync Error: {ex.Message}");
                System.Diagnostics.Debug.WriteLine($"Stack Trace: {ex.StackTrace}");
                if (ex.InnerException != null)
                {
                    System.Diagnostics.Debug.WriteLine($"Inner Exception: {ex.InnerException.Message}");
                }
                
                return ApiResponse<PaginatedResponse<BillDto>>.ErrorResult($"Failed to get bills: {ex.Message}");
            }
        }

        public async Task<ApiResponse<decimal>> GetTotalPendingAmountAsync(string userId)
        {
            try
            {
                var totalAmount = await _context.Bills
                    .Where(b => b.UserId == userId && b.Status == "PENDING")
                    .SumAsync(b => b.Amount);

                return ApiResponse<decimal>.SuccessResult(totalAmount);
            }
            catch (Exception ex)
            {
                return ApiResponse<decimal>.ErrorResult($"Failed to get total pending amount: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillSummaryDto>> GetTotalPaidAmountAsync(string userId, string period)
        {
            try
            {
                var (startDate, endDate) = GetPeriodDates(period);
                
                var totalAmount = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PAID" && 
                               b.PaidAt >= startDate && 
                               b.PaidAt <= endDate)
                    .SumAsync(b => b.Amount);

                var count = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PAID" && 
                               b.PaidAt >= startDate && 
                               b.PaidAt <= endDate)
                    .CountAsync();

                var summary = new BillSummaryDto
                {
                    Amount = totalAmount,
                    Count = count,
                    Period = period.ToUpper(),
                    StartDate = startDate,
                    EndDate = endDate
                };

                return ApiResponse<BillSummaryDto>.SuccessResult(summary);
            }
            catch (Exception ex)
            {
                return ApiResponse<BillSummaryDto>.ErrorResult($"Failed to get total paid amount: {ex.Message}");
            }
        }

        public async Task<ApiResponse<decimal>> GetTotalOverdueAmountAsync(string userId)
        {
            try
            {
                var currentDate = DateTime.UtcNow.Date;
                
                var totalAmount = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING" && 
                               b.DueDate < currentDate)
                    .SumAsync(b => b.Amount);

                return ApiResponse<decimal>.SuccessResult(totalAmount);
            }
            catch (Exception ex)
            {
                return ApiResponse<decimal>.ErrorResult($"Failed to get total overdue amount: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillAnalyticsDto>> GetBillAnalyticsAsync(string userId)
        {
            try
            {
                var currentDate = DateTime.UtcNow.Date;

                var pendingAmount = await _context.Bills
                    .Where(b => b.UserId == userId && b.Status == "PENDING")
                    .SumAsync(b => b.Amount);

                var overdueAmount = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING" && 
                               b.DueDate < currentDate)
                    .SumAsync(b => b.Amount);

                var paidAmount = await _context.Bills
                    .Where(b => b.UserId == userId && b.Status == "PAID")
                    .SumAsync(b => b.Amount);

                var pendingCount = await _context.Bills
                    .Where(b => b.UserId == userId && b.Status == "PENDING")
                    .CountAsync();

                var overdueCount = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING" && 
                               b.DueDate < currentDate)
                    .CountAsync();

                var paidCount = await _context.Bills
                    .Where(b => b.UserId == userId && b.Status == "PAID")
                    .CountAsync();

                var analytics = new BillAnalyticsDto
                {
                    TotalPendingAmount = pendingAmount,
                    TotalPaidAmount = paidAmount,
                    TotalOverdueAmount = overdueAmount,
                    TotalPendingBills = pendingCount,
                    TotalPaidBills = paidCount,
                    TotalOverdueBills = overdueCount,
                    GeneratedAt = DateTime.UtcNow
                };

                return ApiResponse<BillAnalyticsDto>.SuccessResult(analytics);
            }
            catch (Exception ex)
            {
                return ApiResponse<BillAnalyticsDto>.ErrorResult($"Failed to get bill analytics: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillDto>> MarkBillAsPaidAsync(string billId, string userId, string? notes, string? bankAccountId = null)
        {
            // Use database transaction to ensure atomicity
            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                if (bill.Status == "PAID")
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill is already paid");
                }

                // Determine which bank account to use
                Entities.BankAccount? bankAccount = null;
                string? accountIdToUse = bankAccountId;

                // If bankAccountId is not provided, try to get user's first active bank account
                if (string.IsNullOrEmpty(accountIdToUse))
                {
                    bankAccount = await _context.BankAccounts
                        .Where(ba => ba.UserId == userId && ba.IsActive)
                        .OrderByDescending(ba => ba.CurrentBalance) // Use account with highest balance first
                        .FirstOrDefaultAsync();

                    if (bankAccount != null)
                    {
                        accountIdToUse = bankAccount.Id;
                        Console.WriteLine($"DEBUG: Auto-selected bank account: {bankAccount.Id} ({bankAccount.AccountName})");
                    }
                }
                else
                {
                    // Validate the provided bank account
                    bankAccount = await _context.BankAccounts
                        .FirstOrDefaultAsync(ba => ba.Id == accountIdToUse && ba.UserId == userId && ba.IsActive);

                    if (bankAccount == null)
                    {
                        return ApiResponse<BillDto>.ErrorResult("Bank account not found, inactive, or does not belong to user");
                    }
                }

                // Update bill status
                bill.Status = "PAID";
                bill.PaidAt = DateTime.UtcNow;
                bill.UpdatedAt = DateTime.UtcNow;
                
                if (!string.IsNullOrEmpty(notes))
                {
                    bill.Notes = notes;
                }

                // Create payment transaction if bank account is available
                if (bankAccount != null && !string.IsNullOrEmpty(accountIdToUse))
                {
                    // Check if a payment transaction already exists for this bill
                    var existingPayment = await _context.Payments
                        .FirstOrDefaultAsync(p => p.BillId == billId && p.Status == "COMPLETED");

                    if (existingPayment == null)
                    {
                        // Generate a reference number for the payment
                        var paymentReference = $"BILL_PAID_{billId.Substring(0, 8)}_{DateTime.UtcNow:yyyyMMddHHmmss}";

                        // Create payment transaction record
                        var bankTransaction = new Entities.Payment
                        {
                            Id = Guid.NewGuid().ToString(),
                            BillId = billId,
                            BankAccountId = accountIdToUse,
                            UserId = userId,
                            Amount = bill.Amount,
                            Method = "BANK_TRANSFER",
                            Reference = paymentReference,
                            Status = "COMPLETED",
                            IsBankTransaction = true, // This is a bank transaction
                            TransactionType = "DEBIT",
                            Description = $"Bill payment - {bill.BillName}",
                            Category = "BILL_PAYMENT",
                            ExternalTransactionId = $"BILL_PAY_{billId}",
                            Notes = notes,
                            ProcessedAt = DateTime.UtcNow,
                            TransactionDate = DateTime.UtcNow,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        _context.Payments.Add(bankTransaction);
                        Console.WriteLine($"DEBUG: Created payment transaction for bill {billId}. Payment ID: {bankTransaction.Id}");

                        // Update bank account balance (debit - money going out)
                        bankAccount.CurrentBalance -= bill.Amount;
                        var newBalance = bankAccount.CurrentBalance;
                        bankAccount.UpdatedAt = DateTime.UtcNow;

                        // Set balance after transaction
                        bankTransaction.BalanceAfterTransaction = newBalance;

                        // Also create BankTransaction record
                        var bankTxnRecord = new Entities.BankTransaction
                        {
                            Id = Guid.NewGuid().ToString(),
                            BankAccountId = accountIdToUse,
                            UserId = userId,
                            Amount = bill.Amount,
                            TransactionType = "DEBIT",
                            Description = $"Bill payment - {bill.BillName}",
                            Category = "BILL_PAYMENT",
                            ReferenceNumber = paymentReference,
                            ExternalTransactionId = $"BILL_PAY_{billId}",
                            BalanceAfterTransaction = newBalance,
                            TransactionDate = DateTime.UtcNow,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        _context.BankTransactions.Add(bankTxnRecord);

                        // Check if accrual entry exists for this bill (accrual accounting)
                        var accrualEntry = await _context.JournalEntries
                            .FirstOrDefaultAsync(je => je.BillId == billId && je.EntryType == "BILL_ACCRUAL");

                        if (accrualEntry != null)
                        {
                            // Use accrual accounting: Debit Accounts Payable, Credit Bank Account
                            await _accountingService.CreateBillPaymentFromPayableEntryAsync(
                                billId,
                                userId,
                                bill.Amount,
                                bill.BillName,
                                bankAccount.AccountName,
                                paymentReference,
                                $"Bill payment - {bill.BillName}",
                                DateTime.UtcNow
                            );
                        }
                        else
                        {
                            // Fallback to cash basis: Debit Expense, Credit Bank Account (for backward compatibility)
                            await _accountingService.CreateBillPaymentEntryAsync(
                                billId,
                                userId,
                                bill.Amount,
                                bill.BillName,
                                bill.BillType,
                                bankAccount.AccountName,
                                paymentReference,
                                $"Bill payment - {bill.BillName}",
                                DateTime.UtcNow
                            );
                        }
                    }
                }

                await _context.SaveChangesAsync();
                await transaction.CommitAsync();

                var billDto = MapToBillDto(bill);

                return ApiResponse<BillDto>.SuccessResult(billDto, "Bill marked as paid" + (bankAccount != null ? " and transaction recorded" : " (no bank account linked)"));
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
                return ApiResponse<BillDto>.ErrorResult($"Failed to mark bill as paid: {ex.Message}");
            }
        }

        public async Task<ApiResponse<bool>> UpdateBillStatusAsync(string billId, string status, string userId)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<bool>.ErrorResult("Bill not found");
                }

                bill.Status = status.ToUpper();
                bill.UpdatedAt = DateTime.UtcNow;

                if (status.ToUpper() == "PAID" && bill.PaidAt == null)
                {
                    bill.PaidAt = DateTime.UtcNow;
                }

                await _context.SaveChangesAsync();

                return ApiResponse<bool>.SuccessResult(true, "Bill status updated successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<bool>.ErrorResult($"Failed to update bill status: {ex.Message}");
            }
        }

        public async Task<ApiResponse<List<BillDto>>> GetOverdueBillsAsync(string userId)
        {
            try
            {
                var currentDate = DateTime.UtcNow.Date;
                
                var overdueBills = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING" && 
                               b.DueDate < currentDate)
                    .OrderBy(b => b.DueDate)
                    .ToListAsync();

                var billDtos = overdueBills.Select(MapToBillDto).ToList();
                return ApiResponse<List<BillDto>>.SuccessResult(billDtos);
            }
            catch (Exception ex)
            {
                return ApiResponse<List<BillDto>>.ErrorResult($"Failed to get overdue bills: {ex.Message}");
            }
        }

        public async Task<ApiResponse<List<BillDto>>> GetUnpaidAndOverdueBillsAsync(string userId)
        {
            try
            {
                // Get all unpaid (PENDING) bills - this includes both unpaid and overdue bills
                var unpaidBills = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING")
                    .OrderBy(b => b.DueDate)
                    .ToListAsync();

                var billDtos = unpaidBills.Select(MapToBillDto).ToList();
                return ApiResponse<List<BillDto>>.SuccessResult(billDtos);
            }
            catch (Exception ex)
            {
                return ApiResponse<List<BillDto>>.ErrorResult($"Failed to get unpaid and overdue bills: {ex.Message}");
            }
        }

        public async Task<ApiResponse<List<BillDto>>> GetUpcomingBillsAsync(string userId, int days = 7)
        {
            try
            {
                var currentDate = DateTime.UtcNow.Date;
                var futureDate = currentDate.AddDays(days);
                
                var upcomingBills = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.Status == "PENDING" && 
                               b.DueDate >= currentDate && 
                               b.DueDate <= futureDate)
                    .OrderBy(b => b.DueDate)
                    .ToListAsync();

                var billDtos = upcomingBills.Select(MapToBillDto).ToList();
                return ApiResponse<List<BillDto>>.SuccessResult(billDtos);
            }
            catch (Exception ex)
            {
                return ApiResponse<List<BillDto>>.ErrorResult($"Failed to get upcoming bills: {ex.Message}");
            }
        }

        public async Task<ApiResponse<PaginatedResponse<BillDto>>> GetAllBillsAsync(string? status, string? billType, int page, int limit)
        {
            try
            {
                var query = _context.Bills.AsQueryable();

                if (!string.IsNullOrEmpty(status))
                {
                    query = query.Where(b => b.Status == status.ToUpper());
                }

                if (!string.IsNullOrEmpty(billType))
                {
                    query = query.Where(b => b.BillType == billType.ToLower());
                }

                var totalCount = await query.CountAsync();
                var bills = await query
                    .OrderByDescending(b => b.CreatedAt)
                    .Skip((page - 1) * limit)
                    .Take(limit)
                    .ToListAsync();

                var billDtos = bills.Select(MapToBillDto).ToList();

                var paginatedResponse = new PaginatedResponse<BillDto>
                {
                    Data = billDtos,
                    Page = page,
                    Limit = limit,
                    TotalCount = totalCount
                };

                return ApiResponse<PaginatedResponse<BillDto>>.SuccessResult(paginatedResponse);
            }
            catch (Exception ex)
            {
                return ApiResponse<PaginatedResponse<BillDto>>.ErrorResult($"Failed to get all bills: {ex.Message}");
            }
        }

        // Helper Methods
        // ============================================
        // SCHEDULED PAYMENT METHODS
        // ============================================

        public async Task<ApiResponse<BillDto>> ConfigureScheduledPaymentAsync(
            string billId,
            string userId,
            ConfigureScheduledPaymentDto config)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                if (bill.Status == "PAID")
                {
                    return ApiResponse<BillDto>.ErrorResult("Cannot configure scheduled payment for a paid bill");
                }

                bill.IsScheduledPayment = config.IsScheduledPayment;
                bill.ScheduledPaymentBankAccountId = config.ScheduledPaymentBankAccountId;
                bill.ScheduledPaymentDaysBeforeDue = config.ScheduledPaymentDaysBeforeDue;
                bill.UpdatedAt = DateTime.UtcNow;

                // Validate bank account if scheduled payment is enabled
                if (config.IsScheduledPayment && !string.IsNullOrEmpty(config.ScheduledPaymentBankAccountId))
                {
                    var bankAccount = await _context.BankAccounts
                        .FirstOrDefaultAsync(ba => ba.Id == config.ScheduledPaymentBankAccountId &&
                                                   ba.UserId == userId &&
                                                   ba.IsActive);

                    if (bankAccount == null)
                    {
                        return ApiResponse<BillDto>.ErrorResult("Bank account not found, inactive, or does not belong to user");
                    }

                    if (bankAccount.CurrentBalance < bill.Amount)
                    {
                        return ApiResponse<BillDto>.ErrorResult(
                            $"Insufficient balance in selected account. Required: {bill.Amount}, Available: {bankAccount.CurrentBalance}");
                    }
                }

                await _context.SaveChangesAsync();

                var billDto = MapToBillDto(bill);
                return ApiResponse<BillDto>.SuccessResult(billDto, 
                    config.IsScheduledPayment 
                        ? "Scheduled payment configured successfully" 
                        : "Scheduled payment disabled");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to configure scheduled payment: {ex.Message}");
            }
        }

        public async Task<ApiResponse<List<ScheduledPaymentDto>>> GetScheduledPaymentsAsync(string userId)
        {
            try
            {
                var bills = await _context.Bills
                    .Where(b => b.UserId == userId &&
                               b.IsScheduledPayment &&
                               b.Status == "PENDING" &&
                               !b.IsDeleted)
                    .Include(b => b.User)
                    .ToListAsync();

                var scheduledPayments = new List<ScheduledPaymentDto>();

                foreach (var bill in bills)
                {
                    var scheduledPayment = new ScheduledPaymentDto
                    {
                        BillId = bill.Id,
                        BillName = bill.BillName,
                        Amount = bill.Amount,
                        DueDate = bill.DueDate,
                        IsScheduled = bill.IsScheduledPayment,
                        BankAccountId = bill.ScheduledPaymentBankAccountId,
                        DaysBeforeDue = bill.ScheduledPaymentDaysBeforeDue,
                        LastAttempt = bill.LastScheduledPaymentAttempt,
                        FailureReason = bill.ScheduledPaymentFailureReason,
                        Status = bill.Status
                    };

                    // Calculate scheduled payment date
                    if (bill.ScheduledPaymentDaysBeforeDue.HasValue && bill.ScheduledPaymentDaysBeforeDue.Value > 0)
                    {
                        scheduledPayment.ScheduledPaymentDate = bill.DueDate.Date.AddDays(-bill.ScheduledPaymentDaysBeforeDue.Value);
                    }
                    else
                    {
                        scheduledPayment.ScheduledPaymentDate = bill.DueDate.Date;
                    }

                    // Get bank account name
                    if (!string.IsNullOrEmpty(bill.ScheduledPaymentBankAccountId))
                    {
                        var bankAccount = await _context.BankAccounts
                            .FirstOrDefaultAsync(ba => ba.Id == bill.ScheduledPaymentBankAccountId);
                        scheduledPayment.BankAccountName = bankAccount?.AccountName;
                    }

                    scheduledPayments.Add(scheduledPayment);
                }

                return ApiResponse<List<ScheduledPaymentDto>>.SuccessResult(scheduledPayments);
            }
            catch (Exception ex)
            {
                return ApiResponse<List<ScheduledPaymentDto>>.ErrorResult($"Failed to get scheduled payments: {ex.Message}");
            }
        }

        // ============================================
        // BILL APPROVAL METHODS
        // ============================================

        public async Task<ApiResponse<BillDto>> ApproveBillAsync(
            string billId,
            string userId,
            BillApprovalDto approval)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                if (approval.ApprovalStatus != "APPROVED" && approval.ApprovalStatus != "REJECTED")
                {
                    return ApiResponse<BillDto>.ErrorResult("Invalid approval status. Must be APPROVED or REJECTED");
                }

                bill.ApprovalStatus = approval.ApprovalStatus;
                bill.ApprovedBy = userId;
                bill.ApprovedAt = DateTime.UtcNow;
                bill.ApprovalNotes = approval.ApprovalNotes;
                bill.UpdatedAt = DateTime.UtcNow;

                await _context.SaveChangesAsync();

                var billDto = MapToBillDto(bill);
                return ApiResponse<BillDto>.SuccessResult(billDto, $"Bill {approval.ApprovalStatus.ToLower()} successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to approve bill: {ex.Message}");
            }
        }

        // ============================================
        // PAYMENT HISTORY REPORTS
        // ============================================

        public async Task<ApiResponse<BillPaymentHistoryReportDto>> GetBillPaymentHistoryReportAsync(
            string userId,
            string period = "month")
        {
            try
            {
                var today = DateTime.UtcNow.Date;
                DateTime startDate;
                DateTime endDate;

                switch (period.ToLower())
                {
                    case "week":
                        startDate = today.AddDays(-7);
                        endDate = today;
                        break;
                    case "month":
                        startDate = new DateTime(today.Year, today.Month, 1);
                        endDate = today;
                        break;
                    case "quarter":
                        var quarter = (today.Month - 1) / 3;
                        startDate = new DateTime(today.Year, quarter * 3 + 1, 1);
                        endDate = today;
                        break;
                    case "year":
                        startDate = new DateTime(today.Year, 1, 1);
                        endDate = today;
                        break;
                    default:
                        startDate = new DateTime(today.Year, today.Month, 1);
                        endDate = today;
                        break;
                }

                var payments = await _context.Payments
                    .Where(p => p.UserId == userId &&
                               p.BillId != null &&
                               p.Status == "COMPLETED" &&
                               p.ProcessedAt >= startDate &&
                               p.ProcessedAt <= endDate)
                    .Include(p => p.Bill)
                    .OrderByDescending(p => p.ProcessedAt)
                    .ToListAsync();

                var paymentSummaries = new List<BillPaymentSummaryDto>();
                var totalAmountPaid = 0m;
                var scheduledPayments = 0;
                var manualPayments = 0;

                foreach (var payment in payments)
                {
                    var bill = payment.Bill;
                    if (bill == null) continue;

                    var wasScheduled = bill.IsScheduledPayment && 
                                      bill.LastScheduledPaymentAttempt.HasValue &&
                                      bill.LastScheduledPaymentAttempt.Value.Date == payment.ProcessedAt.Date;

                    if (wasScheduled) scheduledPayments++;
                    else manualPayments++;

                    totalAmountPaid += payment.Amount;

                    paymentSummaries.Add(new BillPaymentSummaryDto
                    {
                        BillId = payment.BillId ?? string.Empty,
                        BillName = bill.BillName,
                        Provider = bill.Provider ?? "Unknown",
                        Amount = payment.Amount,
                        PaymentDate = payment.ProcessedAt,
                        PaymentMethod = payment.Method,
                        WasScheduled = wasScheduled,
                        Status = payment.Status
                    });
                }

                var report = new BillPaymentHistoryReportDto
                {
                    ReportDate = DateTime.UtcNow,
                    Period = period,
                    TotalPayments = payments.Count,
                    TotalAmountPaid = totalAmountPaid,
                    ScheduledPayments = scheduledPayments,
                    ManualPayments = manualPayments,
                    Payments = paymentSummaries
                };

                return ApiResponse<BillPaymentHistoryReportDto>.SuccessResult(report);
            }
            catch (Exception ex)
            {
                return ApiResponse<BillPaymentHistoryReportDto>.ErrorResult($"Failed to get payment history report: {ex.Message}");
            }
        }

        private static BillDto MapToBillDto(Bill bill)
        {
            return new BillDto
            {
                Id = bill.Id,
                UserId = bill.UserId,
                BillName = bill.BillName,
                BillType = bill.BillType,
                Amount = bill.Amount,
                DueDate = bill.DueDate,
                Frequency = bill.Frequency,
                Status = bill.Status,
                CreatedAt = bill.CreatedAt,
                UpdatedAt = bill.UpdatedAt,
                PaidAt = bill.PaidAt,
                Notes = bill.Notes,
                Provider = bill.Provider,
                ReferenceNumber = bill.ReferenceNumber,
                AutoGenerateNext = bill.AutoGenerateNext,
                IsAutoGenerated = bill.IsAutoGenerated,
                ConfirmedAt = bill.ConfirmedAt,
                ParentBillId = bill.ParentBillId,
                IsScheduledPayment = bill.IsScheduledPayment,
                ScheduledPaymentBankAccountId = bill.ScheduledPaymentBankAccountId,
                ScheduledPaymentDaysBeforeDue = bill.ScheduledPaymentDaysBeforeDue,
                LastScheduledPaymentAttempt = bill.LastScheduledPaymentAttempt,
                ScheduledPaymentFailureReason = bill.ScheduledPaymentFailureReason,
                ApprovalStatus = bill.ApprovalStatus,
                ApprovedBy = bill.ApprovedBy,
                ApprovedAt = bill.ApprovedAt,
                ApprovalNotes = bill.ApprovalNotes
            };
        }

        private static (DateTime startDate, DateTime endDate) GetPeriodDates(string period)
        {
            var now = DateTime.UtcNow;
            
            return period.ToLower() switch
            {
                "week" => (now.AddDays(-7).Date, now.Date),
                "month" => (now.AddDays(-30).Date, now.Date),
                "quarter" => (now.AddDays(-90).Date, now.Date),
                "year" => (now.AddDays(-365).Date, now.Date),
                _ => (now.AddDays(-30).Date, now.Date) // Default to month
            };
        }

        // Bill Payment Operations
        public async Task<ApiResponse<BillPaymentDto>> MakeBillPaymentAsync(CreateBillPaymentDto payment, string userId)
        {
            try
            {
                Console.WriteLine($"DEBUG: Starting MakeBillPaymentAsync. BillId: {payment.BillId}, Amount: {payment.Amount}, Method: {payment.Method}, Reference: {payment.Reference}");

                // Verify bill exists and belongs to user
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == payment.BillId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillPaymentDto>.ErrorResult("Bill not found");
                }

                if (bill.Status == "PAID")
                {
                    return ApiResponse<BillPaymentDto>.ErrorResult("Bill is already paid");
                }

                // Check if payment reference already exists for this bill
                var existingPayment = await _context.Payments
                    .FirstOrDefaultAsync(p => p.BillId == payment.BillId && p.Reference == payment.Reference);

                if (existingPayment != null)
                {
                    return ApiResponse<BillPaymentDto>.ErrorResult("Payment reference already exists for this bill");
                }

                var methodLower = payment.Method.ToLower();

                // Handle different payment methods
                if (methodLower == "bank transfer" || methodLower == "bank transaction" || methodLower == "bank_transfer" || methodLower == "banktransfer")
                {
                    Console.WriteLine($"DEBUG: Processing bank transfer payment. Method: '{payment.Method}', MethodLower: '{methodLower}'");

                    // Validate bank account for bank transfer
                    if (string.IsNullOrEmpty(payment.BankAccountId))
                    {
                        return ApiResponse<BillPaymentDto>.ErrorResult("BankAccountId is required for Bank transfer method");
                    }

                    // Verify bank account exists and belongs to user
                    var bankAccount = await _context.BankAccounts
                        .FirstOrDefaultAsync(ba => ba.Id == payment.BankAccountId && ba.UserId == userId);

                    Console.WriteLine($"DEBUG: Bank account lookup. BankAccountId: {payment.BankAccountId}, UserId: {userId}, Found: {bankAccount != null}");

                    if (bankAccount == null)
                    {
                        return ApiResponse<BillPaymentDto>.ErrorResult("Bank account not found or does not belong to user");
                    }

                    Console.WriteLine($"DEBUG: Bank account found. CurrentBalance: {bankAccount.CurrentBalance}, AccountName: {bankAccount.AccountName}");

                    // Create single payment record that serves both bill payment and bank transaction
                    var bankTransaction = new Entities.Payment
                    {
                        Id = Guid.NewGuid().ToString(),
                        BillId = payment.BillId,
                        BankAccountId = payment.BankAccountId,
                        UserId = userId,
                        Amount = payment.Amount,
                        Method = "BANK_TRANSFER",
                        Reference = $"BILL_TXN_{payment.Reference}",
                        Status = "COMPLETED",
                        IsBankTransaction = true, // This is a bank transaction
                        TransactionType = "DEBIT",
                        Description = $"Bill payment - {payment.Reference}",
                        Category = "BILL_PAYMENT",
                        ExternalTransactionId = $"BILL_PAY_{payment.Reference}",
                        Notes = payment.Notes,
                        ProcessedAt = DateTime.UtcNow,
                        TransactionDate = DateTime.UtcNow,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.Payments.Add(bankTransaction);
                    Console.WriteLine($"DEBUG: Added combined bill payment + bank transaction to Payments table. ID: {bankTransaction.Id}, Reference: {bankTransaction.Reference}");

                    // Update bank account balance (debit)
                    bankAccount.CurrentBalance -= payment.Amount;
                    var newBalance = bankAccount.CurrentBalance;

                    // Also create BankTransaction record
                    var bankTxnRecord = new Entities.BankTransaction
                    {
                        Id = Guid.NewGuid().ToString(),
                        BankAccountId = payment.BankAccountId,
                        UserId = userId,
                        Amount = payment.Amount,
                        TransactionType = "DEBIT",
                        Description = $"Bill payment - {payment.Reference}",
                        Category = "BILL_PAYMENT",
                        ReferenceNumber = $"BILL_TXN_{payment.Reference}",
                        ExternalTransactionId = $"BILL_PAY_{payment.Reference}",
                        BalanceAfterTransaction = newBalance, // Set the balance after transaction
                        TransactionDate = DateTime.UtcNow,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.BankTransactions.Add(bankTxnRecord);
                    Console.WriteLine($"DEBUG: Added bank transaction to BankTransactions table. ID: {bankTxnRecord.Id}, Reference: {bankTxnRecord.ReferenceNumber}, BalanceAfter: {bankTxnRecord.BalanceAfterTransaction}");

                    // Set balance after transaction for bank transaction Payment record
                    bankTransaction.BalanceAfterTransaction = newBalance;
                    bankAccount.UpdatedAt = DateTime.UtcNow;

                    // Create double-entry journal entry for bill payment (Debit Expense, Credit Bank Account)
                    await _accountingService.CreateBillPaymentEntryAsync(
                        bill.Id,
                        userId,
                        payment.Amount,
                        bill.BillName,
                        bill.BillType,
                        bankAccount.AccountName,
                        payment.Reference,
                        $"Bill payment - {bill.BillName}",
                        DateTime.UtcNow
                    );
                }
                else
                {
                    // Debug: Log that we're processing cash/other payment
                    Console.WriteLine($"DEBUG: Processing cash/other payment. Method: '{payment.Method}', MethodLower: '{methodLower}'");
                    // Cash or other payment methods - only create bill payment record
                    // Note: Cash payments don't create double-entry journal entries as they don't affect bank accounts
                    var billPayment = new Entities.Payment
                    {
                        BillId = payment.BillId,
                        UserId = userId,
                        Amount = payment.Amount,
                        Method = payment.Method,
                        Reference = payment.Reference,
                        Status = "COMPLETED",
                        IsBankTransaction = false, // This is a bill payment only
                        TransactionType = "PAYMENT",
                        Description = $"Bill payment via {payment.Method}",
                        Notes = payment.Notes,
                        ProcessedAt = DateTime.UtcNow,
                        TransactionDate = DateTime.UtcNow,
                        CreatedAt = DateTime.UtcNow,
                        UpdatedAt = DateTime.UtcNow
                    };

                    _context.Payments.Add(billPayment);
                }

                // Update bill status to PAID
                bill.Status = "PAID";
                bill.PaidAt = DateTime.UtcNow;
                bill.UpdatedAt = DateTime.UtcNow;

                try
                {
                    Console.WriteLine($"DEBUG: About to save changes. Entities being tracked:");
                    foreach (var entry in _context.ChangeTracker.Entries())
                    {
                        Console.WriteLine($"  - {entry.Entity.GetType().Name}: {entry.State}");
                    }

                    await _context.SaveChangesAsync();
                    Console.WriteLine($"DEBUG: Successfully saved changes to database. Total changes: {_context.ChangeTracker.Entries().Count()}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"DEBUG: SaveChanges failed with error: {ex.Message}");
                    if (ex.InnerException != null)
                    {
                        Console.WriteLine($"DEBUG: Inner exception: {ex.InnerException.Message}");
                    }
                    throw; // Re-throw to preserve the original error
                }

                // Get the payment record to return
                var billPaymentRecord = await _context.Payments
                    .FirstOrDefaultAsync(p => p.BillId == payment.BillId && 
                                            p.Reference == (methodLower == "bank transfer" || methodLower == "bank transaction" || methodLower == "bank_transfer" || methodLower == "banktransfer" 
                                                ? $"BILL_TXN_{payment.Reference}" 
                                                : payment.Reference));

                if (billPaymentRecord == null)
                {
                    return ApiResponse<BillPaymentDto>.ErrorResult("Failed to retrieve payment record");
                }

                var paymentDto = new BillPaymentDto
                {
                    Id = billPaymentRecord.Id,
                    BillId = billPaymentRecord.BillId,
                    BankAccountId = billPaymentRecord.BankAccountId,
                    UserId = billPaymentRecord.UserId,
                    Amount = billPaymentRecord.Amount,
                    Method = billPaymentRecord.Method,
                    Reference = billPaymentRecord.Reference,
                    Status = billPaymentRecord.Status,
                    IsBankTransaction = billPaymentRecord.IsBankTransaction,
                    TransactionType = billPaymentRecord.TransactionType,
                    Description = billPaymentRecord.Description,
                    Category = billPaymentRecord.Category,
                    ExternalTransactionId = billPaymentRecord.ExternalTransactionId,
                    Notes = billPaymentRecord.Notes,
                    Merchant = billPaymentRecord.Merchant,
                    Location = billPaymentRecord.Location,
                    IsRecurring = billPaymentRecord.IsRecurring,
                    RecurringFrequency = billPaymentRecord.RecurringFrequency,
                    Currency = billPaymentRecord.Currency,
                    BalanceAfterTransaction = billPaymentRecord.BalanceAfterTransaction,
                    ProcessedAt = billPaymentRecord.ProcessedAt,
                    TransactionDate = billPaymentRecord.TransactionDate,
                    CreatedAt = billPaymentRecord.CreatedAt,
                    UpdatedAt = billPaymentRecord.UpdatedAt
                };

                return ApiResponse<BillPaymentDto>.SuccessResult(paymentDto, "Bill payment processed successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillPaymentDto>.ErrorResult($"Failed to process bill payment: {ex.Message}");
            }
        }

        public async Task<ApiResponse<List<BillPaymentDto>>> GetBillPaymentHistoryAsync(string billId, string userId, int page = 1, int limit = 50)
        {
            try
            {
                // Verify bill exists and belongs to user
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<List<BillPaymentDto>>.ErrorResult("Bill not found");
                }

                var payments = await _context.Payments
                    .Where(p => p.BillId == billId)
                    .OrderByDescending(p => p.CreatedAt)
                    .Skip((page - 1) * limit)
                    .Take(limit)
                    .Select(p => new BillPaymentDto
                    {
                        Id = p.Id,
                        BillId = p.BillId,
                        BankAccountId = p.BankAccountId,
                        UserId = p.UserId,
                        Amount = p.Amount,
                        Method = p.Method,
                        Reference = p.Reference,
                        Status = p.Status,
                        IsBankTransaction = p.IsBankTransaction,
                        TransactionType = p.TransactionType,
                        Description = p.Description,
                        Category = p.Category,
                        ExternalTransactionId = p.ExternalTransactionId,
                        Notes = p.Notes,
                        Merchant = p.Merchant,
                        Location = p.Location,
                        IsRecurring = p.IsRecurring,
                        RecurringFrequency = p.RecurringFrequency,
                        Currency = p.Currency,
                        BalanceAfterTransaction = p.BalanceAfterTransaction,
                        ProcessedAt = p.ProcessedAt,
                        TransactionDate = p.TransactionDate,
                        CreatedAt = p.CreatedAt,
                        UpdatedAt = p.UpdatedAt
                    })
                    .ToListAsync();

                return ApiResponse<List<BillPaymentDto>>.SuccessResult(payments, "Bill payment history retrieved successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<List<BillPaymentDto>>.ErrorResult($"Failed to get bill payment history: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillPaymentDto>> GetBillPaymentAsync(string paymentId, string userId)
        {
            try
            {
                var payment = await _context.Payments
                    .Where(p => p.Id == paymentId && p.UserId == userId && p.BillId != null)
                    .Select(p => new BillPaymentDto
                    {
                        Id = p.Id,
                        BillId = p.BillId,
                        BankAccountId = p.BankAccountId,
                        UserId = p.UserId,
                        Amount = p.Amount,
                        Method = p.Method,
                        Reference = p.Reference,
                        Status = p.Status,
                        IsBankTransaction = p.IsBankTransaction,
                        TransactionType = p.TransactionType,
                        Description = p.Description,
                        Category = p.Category,
                        ExternalTransactionId = p.ExternalTransactionId,
                        Notes = p.Notes,
                        Merchant = p.Merchant,
                        Location = p.Location,
                        IsRecurring = p.IsRecurring,
                        RecurringFrequency = p.RecurringFrequency,
                        Currency = p.Currency,
                        BalanceAfterTransaction = p.BalanceAfterTransaction,
                        ProcessedAt = p.ProcessedAt,
                        TransactionDate = p.TransactionDate,
                        CreatedAt = p.CreatedAt,
                        UpdatedAt = p.UpdatedAt
                    })
                    .FirstOrDefaultAsync();

                if (payment == null)
                {
                    return ApiResponse<BillPaymentDto>.ErrorResult("Bill payment not found");
                }

                return ApiResponse<BillPaymentDto>.SuccessResult(payment, "Bill payment retrieved successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillPaymentDto>.ErrorResult($"Failed to get bill payment: {ex.Message}");
            }
        }

        public async Task<ApiResponse<bool>> DeleteBillPaymentAsync(string paymentId, string userId)
        {
            try
            {
                var payment = await _context.Payments
                    .FirstOrDefaultAsync(p => p.Id == paymentId && p.UserId == userId && p.BillId != null);

                if (payment == null)
                {
                    return ApiResponse<bool>.ErrorResult("Bill payment not found or you don't have permission to delete it");
                }

                // Check if payment is too old to delete (e.g., more than 24 hours)
                var hoursSinceCreation = (DateTime.UtcNow - payment.CreatedAt).TotalHours;
                if (hoursSinceCreation > 24)
                {
                    return ApiResponse<bool>.ErrorResult("Cannot delete payment older than 24 hours");
                }

                // If it's a bank transaction, reverse the bank account balance
                if (payment.IsBankTransaction && payment.BankAccountId != null)
                {
                    var bankAccount = await _context.BankAccounts
                        .FirstOrDefaultAsync(ba => ba.Id == payment.BankAccountId);

                    if (bankAccount != null)
                    {
                        // Reverse the transaction (add back the amount)
                        bankAccount.CurrentBalance += payment.Amount;
                        bankAccount.UpdatedAt = DateTime.UtcNow;
                    }

                    // Also delete the corresponding BankTransaction record
                    var bankTransaction = await _context.BankTransactions
                        .FirstOrDefaultAsync(bt => bt.ReferenceNumber == payment.Reference);

                    if (bankTransaction != null)
                    {
                        _context.BankTransactions.Remove(bankTransaction);
                    }
                }

                // Update bill status back to PENDING
                if (payment.BillId != null)
                {
                    var bill = await _context.Bills
                        .FirstOrDefaultAsync(b => b.Id == payment.BillId);

                    if (bill != null)
                    {
                        bill.Status = "PENDING";
                        bill.PaidAt = null;
                        bill.UpdatedAt = DateTime.UtcNow;
                    }
                }

                _context.Payments.Remove(payment);
                await _context.SaveChangesAsync();

                return ApiResponse<bool>.SuccessResult(true, "Bill payment deleted successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<bool>.ErrorResult($"Failed to delete bill payment: {ex.Message}");
            }
        }

        // ============================================
        // Monthly Bill Management Methods
        // ============================================

        public async Task<ApiResponse<List<BillDto>>> GetBillsByMonthAsync(string userId, int year, int month, string? provider = null, string? billType = null)
        {
            try
            {
                var startDate = new DateTime(year, month, 1);
                var endDate = startDate.AddMonths(1).AddDays(-1);

                var query = _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.DueDate >= startDate && 
                               b.DueDate <= endDate);

                if (!string.IsNullOrEmpty(provider))
                {
                    query = query.Where(b => b.Provider == provider);
                }

                if (!string.IsNullOrEmpty(billType))
                {
                    query = query.Where(b => b.BillType == billType.ToLower());
                }

                var bills = await query
                    .OrderBy(b => b.DueDate)
                    .ToListAsync();

                var billDtos = bills.Select(MapToBillDto).ToList();
                return ApiResponse<List<BillDto>>.SuccessResult(billDtos, $"Found {billDtos.Count} bill(s) for {startDate:MMMM yyyy}");
            }
            catch (Exception ex)
            {
                return ApiResponse<List<BillDto>>.ErrorResult($"Failed to get bills by month: {ex.Message}");
            }
        }

        public async Task<ApiResponse<BillDto>> UpdateMonthlyBillAsync(string billId, UpdateMonthlyBillDto updateDto, string userId)
        {
            try
            {
                var bill = await _context.Bills
                    .FirstOrDefaultAsync(b => b.Id == billId && b.UserId == userId);

                if (bill == null)
                {
                    return ApiResponse<BillDto>.ErrorResult("Bill not found");
                }

                // Update the amount
                bill.Amount = updateDto.Amount;
                bill.UpdatedAt = DateTime.UtcNow;

                // Update notes if provided
                if (!string.IsNullOrEmpty(updateDto.Notes))
                {
                    bill.Notes = updateDto.Notes;
                }

                // Update status if provided
                if (!string.IsNullOrEmpty(updateDto.Status))
                {
                    bill.Status = updateDto.Status.ToUpper();
                    
                    // If status is being set to PAID, set PaidAt
                    if (updateDto.Status.ToUpper() == "PAID" && bill.PaidAt == null)
                    {
                        bill.PaidAt = DateTime.UtcNow;
                    }
                }

                await _context.SaveChangesAsync();

                var billDto = MapToBillDto(bill);
                return ApiResponse<BillDto>.SuccessResult(billDto, $"Bill for {bill.DueDate:MMMM yyyy} updated successfully");
            }
            catch (Exception ex)
            {
                return ApiResponse<BillDto>.ErrorResult($"Failed to update monthly bill: {ex.Message}");
            }
        }

        // ============================================
        // Auto-Generated Bills Cleanup Methods
        // ============================================

        /// <summary>
        /// Clean up auto-generated bills that are not within the current year
        /// </summary>
        public async Task<ApiResponse<CleanupResultDto>> CleanupOutOfYearAutoGeneratedBillsAsync(string userId)
        {
            try
            {
                var currentYear = DateTime.UtcNow.Year;
                var startOfCurrentYear = new DateTime(currentYear, 1, 1);
                var endOfCurrentYear = new DateTime(currentYear, 12, 31, 23, 59, 59);

                Console.WriteLine($"DEBUG CLEANUP: Starting cleanup for user {userId}. Current year: {currentYear}");

                // Find all auto-generated bills that are NOT within the current year
                var outOfYearBills = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.IsAutoGenerated && 
                               (b.DueDate < startOfCurrentYear || b.DueDate > endOfCurrentYear))
                    .ToListAsync();

                Console.WriteLine($"DEBUG CLEANUP: Found {outOfYearBills.Count} auto-generated bills outside current year");

                if (!outOfYearBills.Any())
                {
                    return ApiResponse<CleanupResultDto>.SuccessResult(
                        new CleanupResultDto 
                        { 
                            DeletedBillsCount = 0, 
                            DeletedPaymentsCount = 0,
                            DeletedAlertsCount = 0,
                            Message = "No auto-generated bills found outside the current year" 
                        },
                        "No cleanup needed"
                    );
                }

                var billIdsToDelete = outOfYearBills.Select(b => b.Id).ToList();
                Console.WriteLine($"DEBUG CLEANUP: Bill IDs to delete: {string.Join(", ", billIdsToDelete)}");

                // Find and delete related payments
                var relatedPayments = await _context.Payments
                    .Where(p => billIdsToDelete.Contains(p.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG CLEANUP: Found {relatedPayments.Count} related payments");

                var deletedPaymentsCount = 0;
                if (relatedPayments.Any())
                {
                    // Handle bank transactions - reverse balances if needed
                    foreach (var payment in relatedPayments)
                    {
                        if (payment.IsBankTransaction && payment.BankAccountId != null)
                        {
                            Console.WriteLine($"DEBUG CLEANUP: Reversing bank transaction for payment {payment.Id}");
                            
                            var bankAccount = await _context.BankAccounts
                                .FirstOrDefaultAsync(ba => ba.Id == payment.BankAccountId);

                            if (bankAccount != null)
                            {
                                // Reverse the transaction (add back the amount since it was a debit)
                                bankAccount.CurrentBalance += payment.Amount;
                                bankAccount.UpdatedAt = DateTime.UtcNow;
                                Console.WriteLine($"DEBUG CLEANUP: Reversed bank balance by {payment.Amount}");
                            }

                            // Delete the corresponding BankTransaction record
                            var bankTransaction = await _context.BankTransactions
                                .FirstOrDefaultAsync(bt => bt.ReferenceNumber == payment.Reference);

                            if (bankTransaction != null)
                            {
                                _context.BankTransactions.Remove(bankTransaction);
                                Console.WriteLine($"DEBUG CLEANUP: Removed BankTransaction {bankTransaction.Id}");
                            }
                        }
                    }

                    _context.Payments.RemoveRange(relatedPayments);
                    deletedPaymentsCount = relatedPayments.Count;
                }

                // Find and delete related bill alerts
                var relatedAlerts = await _context.BillAlerts
                    .Where(a => billIdsToDelete.Contains(a.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG CLEANUP: Found {relatedAlerts.Count} related alerts");

                var deletedAlertsCount = 0;
                if (relatedAlerts.Any())
                {
                    _context.BillAlerts.RemoveRange(relatedAlerts);
                    deletedAlertsCount = relatedAlerts.Count;
                }

                // Delete the bills
                _context.Bills.RemoveRange(outOfYearBills);
                var deletedBillsCount = outOfYearBills.Count;

                Console.WriteLine($"DEBUG CLEANUP: About to save changes...");
                await _context.SaveChangesAsync();
                Console.WriteLine($"DEBUG CLEANUP: Successfully saved changes");

                // Verify deletion
                var stillExists = await _context.Bills
                    .Where(b => billIdsToDelete.Contains(b.Id))
                    .CountAsync();

                if (stillExists > 0)
                {
                    Console.WriteLine($"DEBUG CLEANUP WARNING: {stillExists} bills still exist after cleanup");
                    return ApiResponse<CleanupResultDto>.ErrorResult($"Cleanup partially failed - {stillExists} bills still remain");
                }

                var result = new CleanupResultDto
                {
                    DeletedBillsCount = deletedBillsCount,
                    DeletedPaymentsCount = deletedPaymentsCount,
                    DeletedAlertsCount = deletedAlertsCount,
                    Message = $"Successfully cleaned up {deletedBillsCount} auto-generated bills outside current year {currentYear}"
                };

                Console.WriteLine($"DEBUG CLEANUP: Cleanup completed successfully. Bills: {deletedBillsCount}, Payments: {deletedPaymentsCount}, Alerts: {deletedAlertsCount}");

                return ApiResponse<CleanupResultDto>.SuccessResult(result,
                    $"Cleanup completed: Removed {deletedBillsCount} auto-generated bills, {deletedPaymentsCount} payments, and {deletedAlertsCount} alerts from outside year {currentYear}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG CLEANUP ERROR: {ex.Message}");
                Console.WriteLine($"DEBUG CLEANUP ERROR STACK: {ex.StackTrace}");
                return ApiResponse<CleanupResultDto>.ErrorResult($"Failed to cleanup out-of-year auto-generated bills: {ex.Message}");
            }
        }

        /// <summary>
        /// Get count of auto-generated bills that are outside the current year
        /// </summary>
        public async Task<ApiResponse<OutOfYearBillsCountDto>> GetOutOfYearAutoGeneratedBillsCountAsync(string userId)
        {
            try
            {
                var currentYear = DateTime.UtcNow.Year;
                var startOfCurrentYear = new DateTime(currentYear, 1, 1);
                var endOfCurrentYear = new DateTime(currentYear, 12, 31, 23, 59, 59);

                var count = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.IsAutoGenerated && 
                               (b.DueDate < startOfCurrentYear || b.DueDate > endOfCurrentYear))
                    .CountAsync();

                var result = new OutOfYearBillsCountDto
                {
                    Count = count,
                    CurrentYear = currentYear,
                    Message = count > 0 
                        ? $"Found {count} auto-generated bills outside current year {currentYear}" 
                        : $"No auto-generated bills found outside current year {currentYear}"
                };

                return ApiResponse<OutOfYearBillsCountDto>.SuccessResult(result);
            }
            catch (Exception ex)
            {
                return ApiResponse<OutOfYearBillsCountDto>.ErrorResult($"Failed to get out-of-year bills count: {ex.Message}");
            }
        }

        /// <summary>
        /// Delete auto-generated bills within a specific date range
        /// </summary>
        public async Task<ApiResponse<CleanupResultDto>> DeleteAutoGeneratedBillsByDateRangeAsync(
            string userId, 
            DateTime startDate, 
            DateTime endDate)
        {
            try
            {
                Console.WriteLine($"DEBUG RANGE DELETE: Starting cleanup for user {userId}. Date range: {startDate:yyyy-MM-dd} to {endDate:yyyy-MM-dd}");

                // Find all auto-generated bills within the specified date range
                var billsToDelete = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.IsAutoGenerated && 
                               b.DueDate >= startDate && 
                               b.DueDate <= endDate)
                    .ToListAsync();

                Console.WriteLine($"DEBUG RANGE DELETE: Found {billsToDelete.Count} auto-generated bills in date range");

                if (!billsToDelete.Any())
                {
                    return ApiResponse<CleanupResultDto>.SuccessResult(
                        new CleanupResultDto 
                        { 
                            DeletedBillsCount = 0, 
                            DeletedPaymentsCount = 0,
                            DeletedAlertsCount = 0,
                            Message = $"No auto-generated bills found between {startDate:yyyy-MM-dd} and {endDate:yyyy-MM-dd}" 
                        },
                        "No cleanup needed"
                    );
                }

                var billIdsToDelete = billsToDelete.Select(b => b.Id).ToList();
                Console.WriteLine($"DEBUG RANGE DELETE: Bill IDs to delete: {string.Join(", ", billIdsToDelete)}");

                // Find and delete related payments
                var relatedPayments = await _context.Payments
                    .Where(p => billIdsToDelete.Contains(p.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG RANGE DELETE: Found {relatedPayments.Count} related payments");

                var deletedPaymentsCount = 0;
                if (relatedPayments.Any())
                {
                    // Handle bank transactions - reverse balances if needed
                    foreach (var payment in relatedPayments)
                    {
                        if (payment.IsBankTransaction && payment.BankAccountId != null)
                        {
                            Console.WriteLine($"DEBUG RANGE DELETE: Reversing bank transaction for payment {payment.Id}");
                            
                            var bankAccount = await _context.BankAccounts
                                .FirstOrDefaultAsync(ba => ba.Id == payment.BankAccountId);

                            if (bankAccount != null)
                            {
                                // Reverse the transaction (add back the amount since it was a debit)
                                bankAccount.CurrentBalance += payment.Amount;
                                bankAccount.UpdatedAt = DateTime.UtcNow;
                                Console.WriteLine($"DEBUG RANGE DELETE: Reversed bank balance by {payment.Amount}");
                            }

                            // Delete the corresponding BankTransaction record
                            var bankTransaction = await _context.BankTransactions
                                .FirstOrDefaultAsync(bt => bt.ReferenceNumber == payment.Reference);

                            if (bankTransaction != null)
                            {
                                _context.BankTransactions.Remove(bankTransaction);
                                Console.WriteLine($"DEBUG RANGE DELETE: Removed BankTransaction {bankTransaction.Id}");
                            }
                        }
                    }

                    _context.Payments.RemoveRange(relatedPayments);
                    deletedPaymentsCount = relatedPayments.Count;
                }

                // Find and delete related bill alerts
                var relatedAlerts = await _context.BillAlerts
                    .Where(a => billIdsToDelete.Contains(a.BillId))
                    .ToListAsync();

                Console.WriteLine($"DEBUG RANGE DELETE: Found {relatedAlerts.Count} related alerts");

                var deletedAlertsCount = 0;
                if (relatedAlerts.Any())
                {
                    _context.BillAlerts.RemoveRange(relatedAlerts);
                    deletedAlertsCount = relatedAlerts.Count;
                }

                // Delete the bills
                _context.Bills.RemoveRange(billsToDelete);
                var deletedBillsCount = billsToDelete.Count;

                Console.WriteLine($"DEBUG RANGE DELETE: About to save changes...");
                await _context.SaveChangesAsync();
                Console.WriteLine($"DEBUG RANGE DELETE: Successfully saved changes");

                // Verify deletion
                var stillExists = await _context.Bills
                    .Where(b => billIdsToDelete.Contains(b.Id))
                    .CountAsync();

                if (stillExists > 0)
                {
                    Console.WriteLine($"DEBUG RANGE DELETE WARNING: {stillExists} bills still exist after cleanup");
                    return ApiResponse<CleanupResultDto>.ErrorResult($"Cleanup partially failed - {stillExists} bills still remain");
                }

                var result = new CleanupResultDto
                {
                    DeletedBillsCount = deletedBillsCount,
                    DeletedPaymentsCount = deletedPaymentsCount,
                    DeletedAlertsCount = deletedAlertsCount,
                    Message = $"Successfully cleaned up {deletedBillsCount} auto-generated bills between {startDate:yyyy-MM-dd} and {endDate:yyyy-MM-dd}"
                };

                Console.WriteLine($"DEBUG RANGE DELETE: Cleanup completed successfully. Bills: {deletedBillsCount}, Payments: {deletedPaymentsCount}, Alerts: {deletedAlertsCount}");

                return ApiResponse<CleanupResultDto>.SuccessResult(result,
                    $"Cleanup completed: Removed {deletedBillsCount} auto-generated bills, {deletedPaymentsCount} payments, and {deletedAlertsCount} alerts from {startDate:yyyy-MM-dd} to {endDate:yyyy-MM-dd}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"DEBUG RANGE DELETE ERROR: {ex.Message}");
                Console.WriteLine($"DEBUG RANGE DELETE ERROR STACK: {ex.StackTrace}");
                return ApiResponse<CleanupResultDto>.ErrorResult($"Failed to cleanup auto-generated bills by date range: {ex.Message}");
            }
        }

        /// <summary>
        /// Get count of auto-generated bills within a specific date range
        /// </summary>
        public async Task<ApiResponse<DateRangeBillsCountDto>> GetAutoGeneratedBillsCountByDateRangeAsync(
            string userId, 
            DateTime startDate, 
            DateTime endDate)
        {
            try
            {
                var count = await _context.Bills
                    .Where(b => b.UserId == userId && 
                               b.IsAutoGenerated && 
                               b.DueDate >= startDate && 
                               b.DueDate <= endDate)
                    .CountAsync();

                var result = new DateRangeBillsCountDto
                {
                    Count = count,
                    StartDate = startDate,
                    EndDate = endDate,
                    Message = count > 0 
                        ? $"Found {count} auto-generated bills between {startDate:yyyy-MM-dd} and {endDate:yyyy-MM-dd}" 
                        : $"No auto-generated bills found between {startDate:yyyy-MM-dd} and {endDate:yyyy-MM-dd}"
                };

                return ApiResponse<DateRangeBillsCountDto>.SuccessResult(result);
            }
            catch (Exception ex)
            {
                return ApiResponse<DateRangeBillsCountDto>.ErrorResult($"Failed to get bills count by date range: {ex.Message}");
            }
        }
    }
}
